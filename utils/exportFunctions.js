/**\n * Export Functions\n * PDF, EPUB, DOCX export with RTL support\n */\n\nimport jsPDF from 'jspdf'\nimport { Document, Packer, Paragraph, TextRun, PageBreak, HeadingLevel, AlignmentType } from 'docx'\nimport JSZip from 'jszip'\n\n/**\n * Export to PDF with RTL support\n */\nexport async function exportToPDF(manuscript) {\n  try {\n    const pdf = new jsPDF({\n      orientation: 'portrait',\n      unit: 'mm',\n      format: 'a4',\n      compress: true\n    })\n\n    // Set RTL for Arabic\n    pdf.setR2L(true)\n\n    // Add metadata\n    pdf.setProperties({\n      title: manuscript.title,\n      author: manuscript.author || 'Unknown',\n      subject: manuscript.description || '',\n      keywords: manuscript.genre || ''\n    })\n\n    // Set font (support Arabic)\n    pdf.addFont('assets/fonts/Arial.ttf', 'Arial', 'normal')\n    pdf.setFont('Arial')\n\n    // Add title\n    pdf.setFontSize(24)\n    pdf.text(manuscript.title, 105, 20, { align: 'center', maxWidth: 180 })\n\n    // Add metadata\n    pdf.setFontSize(10)\n    pdf.setTextColor(100)\n    let yPosition = 40\n\n    if (manuscript.author) {\n      pdf.text(`المؤلف: ${manuscript.author}`, 105, yPosition, { align: 'center' })\n      yPosition += 10\n    }\n\n    if (manuscript.genre) {\n      pdf.text(`النوع: ${manuscript.genre}`, 105, yPosition, { align: 'center' })\n      yPosition += 10\n    }\n\n    if (manuscript.publication_date) {\n      pdf.text(`تاريخ النشر: ${new Date(manuscript.publication_date).toLocaleDateString('ar-SA')}`, 105, yPosition, { align: 'center' })\n      yPosition += 10\n    }\n\n    // Add separator\n    pdf.setDrawColor(200)\n    pdf.line(20, yPosition + 5, 190, yPosition + 5)\n    yPosition += 15\n\n    // Add content\n    pdf.setTextColor(0)\n    pdf.setFontSize(12)\n\n    const pageHeight = pdf.internal.pageSize.getHeight()\n    const pageWidth = pdf.internal.pageSize.getWidth()\n    const margin = 20\n    const maxWidth = pageWidth - 2 * margin\n\n    // Split content into lines\n    const lines = pdf.splitTextToSize(manuscript.content || '', maxWidth)\n\n    lines.forEach((line) => {\n      if (yPosition > pageHeight - margin) {\n        pdf.addPage()\n        yPosition = margin\n      }\n      pdf.text(line, pageWidth - margin, yPosition, { align: 'right' })\n      yPosition += 7\n    })\n\n    // Add footer\n    const pageCount = pdf.getNumberOfPages()\n    for (let i = 1; i <= pageCount; i++) {\n      pdf.setPage(i)\n      pdf.setFontSize(9)\n      pdf.setTextColor(150)\n      pdf.text(\n        `صفحة ${i} من ${pageCount}`,\n        105,\n        pageHeight - 10,\n        { align: 'center' }\n      )\n    }\n\n    return pdf.output('arraybuffer')\n  } catch (error) {\n    console.error('PDF export error:', error)\n    throw new Error(`فشل تصدير PDF: ${error.message}`)\n  }\n}\n\n/**\n * Export to EPUB\n */\nexport async function exportToEPUB(manuscript) {\n  try {\n    const zip = new JSZip()\n\n    // Create EPUB structure\n    zip.file('mimetype', 'application/epub+zip')\n\n    // Create META-INF/container.xml\n    const containerXml = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<container version=\"1.0\" xmlns=\"urn:oasis:names:tc:opendocument:xmlns:container\">\n  <rootfiles>\n    <rootfile full-path=\"OEBPS/content.opf\" media-type=\"application/oebps-package+xml\"/>\n  </rootfiles>\n</container>`\n    zip.file('META-INF/container.xml', containerXml)\n\n    // Create OEBPS/content.opf\n    const contentOpf = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<package xmlns=\"http://www.idpf.org/2007/opf\" version=\"3.0\" unique-identifier=\"uuid_id\">\n  <metadata xmlns:dc=\"http://purl.org/dc/elements/1.1/\">\n    <dc:title>${escapeXml(manuscript.title)}</dc:title>\n    <dc:creator>${escapeXml(manuscript.author || 'Unknown')}</dc:creator>\n    <dc:description>${escapeXml(manuscript.description || '')}</dc:description>\n    <dc:language>ar</dc:language>\n    <dc:date>${new Date().toISOString()}</dc:date>\n    <dc:identifier id=\"uuid_id\">urn:uuid:${generateUUID()}</dc:identifier>\n  </metadata>\n  <manifest>\n    <item id=\"ncx\" href=\"toc.ncx\" media-type=\"application/x-dtbncx+xml\"/>\n    <item id=\"nav\" href=\"nav.xhtml\" media-type=\"application/xhtml+xml\" properties=\"nav\"/>\n    <item id=\"content\" href=\"content.xhtml\" media-type=\"application/xhtml+xml\"/>\n  </manifest>\n  <spine toc=\"ncx\">\n    <itemref idref=\"nav\"/>\n    <itemref idref=\"content\"/>\n  </spine>\n</package>`\n    zip.file('OEBPS/content.opf', contentOpf)\n\n    // Create OEBPS/content.xhtml\n    const contentXhtml = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" dir=\"rtl\">\n<head>\n  <meta charset=\"UTF-8\"/>\n  <title>${escapeXml(manuscript.title)}</title>\n  <style>\n    body { font-family: Arial, sans-serif; direction: rtl; text-align: right; }\n    h1 { font-size: 2em; margin-bottom: 0.5em; }\n    p { margin: 1em 0; line-height: 1.6; }\n  </style>\n</head>\n<body>\n  <h1>${escapeXml(manuscript.title)}</h1>\n  <p><strong>${escapeXml(manuscript.author || '')}</strong></p>\n  <hr/>\n  ${manuscript.content ? manuscript.content.split('\\n').map(p => `<p>${escapeXml(p)}</p>`).join('') : ''}\n</body>\n</html>`\n    zip.file('OEBPS/content.xhtml', contentXhtml)\n\n    // Create OEBPS/toc.ncx\n    const tocNcx = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE ncx PUBLIC \"-//NISO//DTD ncx 2005-1//EN\" \"http://www.daisy.org/z3986/2005/ncx-2005-1.dtd\">\n<ncx xmlns=\"http://www.daisy.org/z3986/2005/ncx/\" version=\"2005-1\">\n  <head>\n    <meta name=\"dtb:uid\" content=\"urn:uuid:${generateUUID()}\"/>\n    <meta name=\"dtb:depth\" content=\"1\"/>\n    <meta name=\"dtb:totalPageCount\" content=\"0\"/>\n    <meta name=\"dtb:maxPageNumber\" content=\"0\"/>\n  </head>\n  <docTitle>\n    <text>${escapeXml(manuscript.title)}</text>\n  </docTitle>\n  <navMap>\n    <navPoint id=\"navpoint-1\" playOrder=\"1\">\n      <navLabel>\n        <text>${escapeXml(manuscript.title)}</text>\n      </navLabel>\n      <content src=\"content.xhtml\"/>\n    </navPoint>\n  </navMap>\n</ncx>`\n    zip.file('OEBPS/toc.ncx', tocNcx)\n\n    // Create OEBPS/nav.xhtml\n    const navXhtml = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\" dir=\"rtl\">\n<head>\n  <meta charset=\"UTF-8\"/>\n  <title>جدول المحتويات</title>\n</head>\n<body>\n  <nav epub:type=\"toc\">\n    <h1>جدول المحتويات</h1>\n    <ol>\n      <li><a href=\"content.xhtml\">${escapeXml(manuscript.title)}</a></li>\n    </ol>\n  </nav>\n</body>\n</html>`\n    zip.file('OEBPS/nav.xhtml', navXhtml)\n\n    return zip.generateAsync({ type: 'arraybuffer' })\n  } catch (error) {\n    console.error('EPUB export error:', error)\n    throw new Error(`فشل تصدير EPUB: ${error.message}`)\n  }\n}\n\n/**\n * Export to DOCX\n */\nexport async function exportToDOCX(manuscript) {\n  try {\n    const sections = []\n\n    // Add title\n    sections.push(\n      new Paragraph({\n        text: manuscript.title,\n        heading: HeadingLevel.HEADING_1,\n        alignment: AlignmentType.CENTER,\n        spacing: { after: 400 }\n      })\n    )\n\n    // Add metadata\n    if (manuscript.author) {\n      sections.push(\n        new Paragraph({\n          text: `المؤلف: ${manuscript.author}`,\n          alignment: AlignmentType.CENTER,\n          spacing: { after: 200 }\n        })\n      )\n    }\n\n    if (manuscript.genre) {\n      sections.push(\n        new Paragraph({\n          text: `النوع: ${manuscript.genre}`,\n          alignment: AlignmentType.CENTER,\n          spacing: { after: 200 }\n        })\n      )\n    }\n\n    if (manuscript.publication_date) {\n      sections.push(\n        new Paragraph({\n          text: `تاريخ النشر: ${new Date(manuscript.publication_date).toLocaleDateString('ar-SA')}`,\n          alignment: AlignmentType.CENTER,\n          spacing: { after: 400 }\n        })\n      )\n    }\n\n    // Add content\n    const contentLines = (manuscript.content || '').split('\\n')\n    contentLines.forEach((line, index) => {\n      if (line.trim()) {\n        sections.push(\n          new Paragraph({\n            text: line,\n            alignment: AlignmentType.JUSTIFIED,\n            spacing: { line: 360, after: 200 },\n            direction: 'rtl'\n          })\n        )\n      }\n    })\n\n    const doc = new Document({\n      sections: [\n        {\n          children: sections\n        }\n      ]\n    })\n\n    const buffer = await Packer.toBuffer(doc)\n    return buffer\n  } catch (error) {\n    console.error('DOCX export error:', error)\n    throw new Error(`فشل تصدير DOCX: ${error.message}`)\n  }\n}\n\n/**\n * Export to ZIP (all formats)\n */\nexport async function exportToZIP(manuscript) {\n  try {\n    const zip = new JSZip()\n\n    // Export PDF\n    const pdfBuffer = await exportToPDF(manuscript)\n    zip.file(`${sanitizeFilename(manuscript.title)}.pdf`, pdfBuffer)\n\n    // Export EPUB\n    const epubBuffer = await exportToEPUB(manuscript)\n    zip.file(`${sanitizeFilename(manuscript.title)}.epub`, epubBuffer)\n\n    // Export DOCX\n    const docxBuffer = await exportToDOCX(manuscript)\n    zip.file(`${sanitizeFilename(manuscript.title)}.docx`, docxBuffer)\n\n    // Add metadata file\n    const metadata = {\n      title: manuscript.title,\n      author: manuscript.author,\n      description: manuscript.description,\n      genre: manuscript.genre,\n      wordCount: manuscript.word_count,\n      exportDate: new Date().toISOString()\n    }\n    zip.file('metadata.json', JSON.stringify(metadata, null, 2))\n\n    return zip.generateAsync({ type: 'arraybuffer' })\n  } catch (error) {\n    console.error('ZIP export error:', error)\n    throw new Error(`فشل تصدير ZIP: ${error.message}`)\n  }\n}\n\n/**\n * Helper: Escape XML special characters\n */\nfunction escapeXml(str) {\n  if (!str) return ''\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&apos;')\n}\n\n/**\n * Helper: Generate UUID\n */\nfunction generateUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16) | 0\n    const v = c === 'x' ? r : (r & 0x3) | 0x8\n    return v.toString(16)\n  })\n}\n\n/**\n * Helper: Sanitize filename\n */\nfunction sanitizeFilename(filename) {\n  return filename\n    .replace(/[^\\w\\s-]/g, '')\n    .replace(/\\s+/g, '-')\n    .toLowerCase()\n    .substring(0, 50)\n}\n\n/**\n * Main export function\n */\nexport async function exportManuscript(manuscript, format = 'pdf') {\n  try {\n    let buffer\n    let mimeType\n    let filename\n\n    switch (format.toLowerCase()) {\n      case 'pdf':\n        buffer = await exportToPDF(manuscript)\n        mimeType = 'application/pdf'\n        filename = `${sanitizeFilename(manuscript.title)}.pdf`\n        break\n\n      case 'epub':\n        buffer = await exportToEPUB(manuscript)\n        mimeType = 'application/epub+zip'\n        filename = `${sanitizeFilename(manuscript.title)}.epub`\n        break\n\n      case 'docx':\n        buffer = await exportToDOCX(manuscript)\n        mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n        filename = `${sanitizeFilename(manuscript.title)}.docx`\n        break\n\n      case 'zip':\n        buffer = await exportToZIP(manuscript)\n        mimeType = 'application/zip'\n        filename = `${sanitizeFilename(manuscript.title)}-all-formats.zip`\n        break\n\n      default:\n        throw new Error(`صيغة غير مدعومة: ${format}`)\n    }\n\n    // Create blob and download\n    const blob = new Blob([buffer], { type: mimeType })\n    const url = URL.createObjectURL(blob)\n    const link = document.createElement('a')\n    link.href = url\n    link.download = filename\n    document.body.appendChild(link)\n    link.click()\n    document.body.removeChild(link)\n    URL.revokeObjectURL(url)\n\n    return { success: true, filename, size: buffer.byteLength }\n  } catch (error) {\n    console.error('Export error:', error)\n    throw error\n  }\n}\n
